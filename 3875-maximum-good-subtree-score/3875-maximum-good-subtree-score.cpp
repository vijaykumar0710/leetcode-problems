class Solution {
private:
    vector<vector<int>> adj; // Adjacency list for the tree
    vector<int> node_digit_mask;  // Stores the digit mask for each vals[i]
    long long total_sum_of_max_scores; // Accumulates sum of maxScore[u] values
    const long long MOD = 1e9 + 7;     // Modulo value

    // Helper to get digit mask for a number
    // Returns -1 if number has duplicate digits (e.g., 22)
    int get_digit_mask(int num) {
        int mask = 0;
        string s_num = to_string(num);
        for (char c : s_num) {
            int digit = c - '0';
            if (mask&(1<<digit)) { // If digit already seen
                return -1; // Duplicate digit found, this number cannot be part of a good subset
            }
            mask |= (1 << digit); // Set the bit for this digit
        }
        return mask;
    }

    // Main DFS function to compute max_score for each subtree
    // Returns a map<mask, max_score> for the current subtree.
    map<int, long long> dfs_solve(int u, int p, vector<int>& vals) {
        // Initialize map for node 'u'.
        // An empty subset (mask 0) always has a sum of 0.
        map<int, long long> u_dp_map;
        u_dp_map[0] = 0; 

        // Process children recursively
        for (int v : adj[u]) {
            if (v == p) continue; // Skip parent

            // Get the DP map from the child's subtree
            map<int, long long> v_dp_map = dfs_solve(v, u, vals);

            // Merge v_dp_map into u_dp_map
            // Create a temporary map to store new combinations from merging
            map<int, long long> merged_map_from_child;
            
            // Iterate through all existing combinations in u_dp_map
            for (auto const& [mask1, sum1] : u_dp_map) {
                // Iterate through all combinations from child's map
                for (auto const& [mask2, sum2] : v_dp_map) {
                    if ((mask1 & mask2) == 0) { // If masks have no common set bits (no conflicting digits)
                        int combined_mask = mask1 | mask2;
                        long long combined_sum = sum1 + sum2;
                        // Update the new_combinations map with the maximum sum for this combined_mask
                        merged_map_from_child[combined_mask] = max(merged_map_from_child[combined_mask], combined_sum);
                    }
                }
            }
            // Add the new combinations generated by merging with child's map to u_dp_map
            for (auto const& [mask, sum] : merged_map_from_child) {
                u_dp_map[mask] = max(u_dp_map[mask], sum);
            }
        }

        // Now, consider including the current node 'u' itself in subsets.
        // Its value is vals[u], and its digit mask is node_digit_mask[u].
        
        // If vals[u] itself has duplicate digits, it cannot be part of any good subset.
        // So, we only consider it if its digit mask is valid (-1 means invalid).
        if (node_digit_mask[u] != -1) { 
            // Create a temporary map to store combinations that include vals[u]
            std::map<int, long long> combinations_with_u;
            
            // The subset containing only 'u'
            combinations_with_u[node_digit_mask[u]] = vals[u]; 

            // Combine 'u' with existing good subsets from its children's subtrees (already in u_dp_map)
            for (auto const& [mask_prev, sum_prev] : u_dp_map) {
                if ((mask_prev & node_digit_mask[u]) == 0) { // If no conflicting digits with vals[u]
                    int combined_mask = mask_prev | node_digit_mask[u];
                    long long combined_sum = sum_prev + vals[u];
                    combinations_with_u[combined_mask] = std::max(combinations_with_u[combined_mask], combined_sum);
                }
            }

            // Add these new combinations (including 'u') to u_dp_map
            for (auto const& [mask, sum] : combinations_with_u) {
                u_dp_map[mask] = std::max(u_dp_map[mask], sum);
            }
        }
        
        // Calculate max_score[u] for the current node 'u'.
        // This is the maximum sum among all good subsets found in u's subtree.
        long long current_max_score_for_u = 0;
        for (auto const& [mask, score] : u_dp_map) {
            current_max_score_for_u = std::max(current_max_score_for_u, score);
        }
        
        // Add max_score[u] to the total sum of all maxScores (modulo 10^9 + 7)
        total_sum_of_max_scores = (total_sum_of_max_scores + current_max_score_for_u) % MOD;

        return u_dp_map; // Return the map for the parent to use
    }

public:
    int goodSubtreeSum(std::vector<int>& vals, std::vector<int>& par) {
        int n = vals.size();
        adj.assign(n, {});
        node_digit_mask.assign(n, 0);
        total_sum_of_max_scores = 0;

        // Precompute digit masks for all values
        for (int i = 0; i < n; ++i) {
            node_digit_mask[i] = get_digit_mask(vals[i]);
        }
        for (int i = 1; i < n; ++i) {
            adj[par[i]].push_back(i);
            adj[i].push_back(par[i]);
        }
        dfs_solve(0, -1, vals);

        return static_cast<int>(total_sum_of_max_scores);
    }
};